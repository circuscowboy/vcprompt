#!/usr/bin/env python
"""
Usage: vcprompt [options]

Version control information in your prompt.

Options:
  -f, --format FORMAT        The format string to use.
  -p, --path PATH            The path to run vcprompt on.
  -u, --unknown UNKNOWN      The "unknown" value.
  -s, --systems              Print all known VCSs and exit
  -h, --help                 Show this help message and exit

VCS-specific formatting:
  These options can be used for VCS-specific prompt formatting.

  --format-bzr FORMAT        Bazaar
  --format-cvs FORMAT        CVS
  --format-darcs FORMAT      Darcs
  --format-fossil FORMAT     Fossil
  --format-git FORMAT        Git
  --format-hg FORMAT         Mercurial
  --format-svn FORMAT        Subversion

Format tokens:
  %s, %n                     The VCS "short name" (e.g. git, hg)
  %h                         The hash (or revision number)
  %r                         The revision number (or hash)
  %b                         The currently checked out branch
"""

import linecache
import optparse
import os
import re
import sqlite3
import sys


# check to make sure the '--without-environment' flag is called first
# this could be done in a callback, but we'd have to keep a note of every
# option which is affected by this flag
if '--without-environment' in sys.argv and \
   sys.argv[1] != '--without-environment':
    output = "The '--without-environment' option must come before any "
    sys.stderr.write('%s other options.\n' % output)
    sys.exit(1)

# we need to get this in early because callbacks are always called after
# every other option is already set, regardless of when the callback option
# is actually used in the script
if len(sys.argv) > 1 and sys.argv[1] == '--without-environment':
    for k in list(os.environ.keys()):
        if k.startswith('VCPROMPT'):
            del os.environ[k]
    del sys.argv[1]


# user editable options
FORMAT = os.environ.get('VCPROMPT_FORMAT', '%s:%b')
UNKNOWN = os.environ.get('VCPROMPT_UNKNOWN', '(unknown)')
SYSTEMS = []


def helper(*args, **kwargs):
    """
    Prints the help message to stderr.
    """
    sys.stderr.write(__doc__.strip() + '\n')
    sys.exit(0)


def systems(*args, **kwargs):
    """Prints all available systems to stdout."""
    for system in SYSTEMS:
        sys.stdout.write(system.__name__ + '\n')
    sys.exit(0)


def vcs(files):
    """
    A convenience decorator.

    Wraps a VCS function, appending it to ``SYSTEMS`` and sets the ``file``
    attribute.
    """
    def wrapper(function):
        SYSTEMS.append(function)
        function.files = files
        return function
    return wrapper


def version(*args):
    """
    Convenience function for printing a version number.
    """
    sys.stdout.write('vcprompt %s' % '.'.join(map(str, __version__)))
    sys.exit(0)


def vcprompt(options):
    """
    Returns a formatted version control string for use in a shell prompt
    or elsewhere.

    Arguments:

        ``options``
            An optparse.Values instance.

    """
    options.path = os.path.abspath(os.path.expanduser(options.path))
    prompt = None

    while options.path:
        # bail out on non-existant paths
        if not os.path.exists(options.path):
            break

        # We need to change the current working directory or the '--path'
        # flag might not work correctly with some formatting args.
        # It's easier to do this here, rather than in every VCS function
        if options.path != os.getcwd():
            os.chdir(options.path)

        for vcs in SYSTEMS:
            for vfile in vcs.files:
                if not os.path.exists(vfile):
                    continue

                # set up custom formatting
                vcs_format = getattr(options, 'format-' + vcs.__name__, None)
                if vcs_format:
                    options.format = vcs_format

                # the "vcs" file
                options.file = vfile

                prompt = vcs(options)
                if prompt is not None:
                    return prompt

        options.path = options.path.rsplit('/', 1)[0]
    return ''


def main():
    parser = optparse.OptionParser()
    parser.remove_option('--help')
    parser.add_option('-h', '--help', action='callback', callback=helper)
    parser.add_option('-f', '--format', dest='format', default=FORMAT)
    parser.add_option('-p', '--path', dest='path', default='.')
    parser.add_option('-s', '--systems', action='callback', callback=systems)
    parser.add_option('-u', '--unknown', dest='unknown', default=UNKNOWN)

    # vcs-specific formatting
    for system in SYSTEMS:
        default = 'VCPROMPT_FORMAT_%s' % system.__name__.upper()
        default = os.environ.get(default, None)
        dest = 'format-%s' % system.__name__
        flag = '--%s' % dest
        parser.add_option(flag, dest=dest, default=default)

    options, args = parser.parse_args()
    output = vcprompt(options)

    return output


@vcs([".bzr/branch/last-revision"])
def bzr(options):
    """
    Bazaar

    The Bazaar version control system
    """
    branch = revision = sha = options.unknown

    # local revision or global sha
    if re.search('%(r|h)', options.format):
        with open(options.file, 'r') as fh:
            revision, sha = fh.readline().strip().split(' ', 1)
            if sha == 'null:':
                sha = options.unknown
            else:
                sha = sha.rsplit('-', 1)[-1][:7]

    # formatting
    output = options.format
    output = output.replace('%b', os.path.basename(options.path))
    output = output.replace('%h', sha)
    output = output.replace('%r', revision)
    output = output.replace('%s', 'bzr')
    output = output.replace('%n', 'bzr')
    return output


@vcs(["CVS"])
def cvs(options):
    """
    CVS

    Concurrent Versions System.
    """
    output = options.format
    output = output.replace('%b', options.unknown)
    output = output.replace('%h', options.unknown)
    output = output.replace('%r', options.unknown)
    output = output.replace('%s', 'cvs')
    output = output.replace('%n', 'cvs')
    return output


@vcs(["_darcs"])
def darcs(options):
    """
    Darcs

    Distributed. Interactive. Smart.
    """
    output = options.format
    output = output.replace('%b', os.path.basename(options.path))
    output = output.replace('%h', options.unknown)
    output = output.replace('%r', options.unknown)
    output = output.replace('%s', 'darcs')
    output = output.replace('%n', 'darcs')
    return output


@vcs([".fslckout", "_FOSSIL_"])
def fossil(options):
    """
    Fossil

    The Fossil version control system.
    """
    branch = sha = options.unknown

    # all this just to get the repository file :(
    repository = None
    try:
        conn = None
        try:
            query = "SELECT value FROM vvar where name = 'repository'"
            conn = sqlite3.connect(options.file)
            c = conn.cursor()
            c.execute(query)
            repository = c.fetchone()[0]
        except sqlite3.OperationalError:
            pass
    finally:
        if conn:
            conn.close()

    # grab the sha from the repo
    if repository is not None:
        try:
            conn = None
            try:
                query = "SELECT uuid from blob ORDER BY rid DESC LIMIT 1"
                conn = sqlite3.connect(repository)
                c = conn.cursor()
                c.execute(query)
                sha = c.fetchone()[0][:7]
            except sqlite3.OperationalError:
                pass
        finally:
            if conn:
                conn.close()

    # branch
    if sha != options.unknown:
        try:
            conn = None
            try:
                query = """SELECT value FROM tagxref WHERE rid =
                           (SELECT rid FROM blob WHERE uuid LIKE '%s%%')
                           AND value is not NULL LIMIT 1 """ % sha
                conn = sqlite3.connect(repository)
                c = conn.cursor()
                c.execute(query)
                branch = c.fetchone()[0]
            except (sqlite3.OperationalError, TypeError):
                pass
        finally:
            if conn:
                conn.close()

    # parse out formatting string
    output = options.format
    output = output.replace('%b', branch)
    output = output.replace('%h', sha)
    output = output.replace('%r', sha)
    output = output.replace('%s', 'fossil')
    output = output.replace('%n', 'fossil')
    return output


@vcs([".git"])
def git(options):
    """
    Git

    The fast version control system.
    """
    branch = sha = options.unknown

    # find the "real" .git directory for submodules
    if os.path.isfile(options.file):
        options.file = open(options.file, "r").read().strip().split(" ", 1)[1]

    # the current branch is required to get the sha
    if re.search('%(b|r|h)', options.format):
        branch_file = os.path.join(options.file, 'HEAD')
        with open(branch_file, 'r') as fh:
            branch = (fh.readline().strip().split('/', 2)[-1] or options.unknown)


        # sha/revision
        if re.search('%(r|h)', options.format) and branch != options.unknown:
            sha_file = os.path.join(options.file, 'refs/heads/%s' % branch)
            with open(sha_file, 'r') as fh:
                sha = fh.readline().strip()[0:7]


    # formatting
    output = options.format
    output = output.replace('%b', branch)
    output = output.replace('%h', sha)
    output = output.replace('%r', sha)
    output = output.replace('%s', 'git')
    output = output.replace('%n', 'git')
    return output


@vcs([".hg"])
def hg(options):
    """
    Mercurial

    The Mercurial version control system.
    """
    branch = revision = sha = options.unknown

    # changeset ID or global sha
    if re.search('%(r|h)', options.format):
        with open(os.path.join(options.file, 'cache/branchheads'), 'r') as fh:
            sha, revision = fh.readline().strip().split()
            sha = sha[:7]

    # branch
    if '%b' in options.format:
        file = os.path.join(options.file, 'undo.branch')
        with open(file, 'r') as fh:
            branch = fh.readline().strip()

    output = options.format
    output = output.replace('%b', branch)
    output = output.replace('%h', sha)
    output = output.replace('%r', revision)
    output = output.replace('%s', 'hg')
    output = output.replace('%n', 'hg')
    return output


@vcs([".svn"])
def svn(options):
    """
    Subversion

    The Subversion version control system.
    """
    branch = revision = options.unknown

    # svn 1.7 uses SQLite
    if os.path.isfile(os.path.join(options.file, 'wc.db')):
        try:
            conn = sqlite3.connect(os.path.join(options.file, 'wc.db'))
            conn.isolation_level = None
            c = conn.cursor()
            c.execute("SELECT parent_relpath, revision FROM NODES WHERE kind = 'dir' AND parent_relpath IS NOT NULL")
            for row in c.fetchall():
                if options.path.endswith(row[0]):
                    revision = str(row[1])
                    break
            conn.close()
        except sqlite3.Error as e:
            pass
    else:
        options.file = os.path.join(options.file, 'entries')
        if re.search('%(h|r)', options.format):
            revision = linecache.getline(options.file, 4).strip()

    # formatting
    output = options.format
    output = output.replace('%r', revision)
    output = output.replace('%h', revision)
    output = output.replace('%b', branch)
    output = output.replace('%s', 'svn')
    output = output.replace('%n', 'svn')
    return output


if __name__ == '__main__':
    prompt = main()
    if prompt:
        sys.stdout.write(prompt + '\n')
    else:
        sys.exit(1)
